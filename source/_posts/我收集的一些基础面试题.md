---
title: 我收集的一些基础面试题
date: 2017-09-22 16:29:49
tags: [面试,前端]
---
##### 写在前面
我收集的也有我遇到过的面试题, 会持续更新.

### HTML

* 前端工程化的理解
模块化、组件化、规范化、自动化
```html
1.模块化 将文件拆分成互相依赖的小文件, 多人协作开发后, 再进行统一的拼装.
js模块化 commonjs amd cmd
css模块化 命名风格. 在类前加规范, 如布局(grid)(.g-xxx) 功能(function)(.f-xxx)

2.组件化 每个包含html+css+js完备的单元, 成为组件
3.规范化 目录结构的确定, 前后端接口规范, 组件命名规范 commit描述规范
4.自动化 简单的机械劳动, 让机器帮我们完成. 线上发布 => 使用脚本 图片<20kb => webpack转base64
```

* 如何html中开启和关闭dns预读取
```html
<!-- on打开 off关闭 -->
<meta http-equiv="x-dns-prefetch-control" content="off">

<!-- 方法二 通过link的rel属性 -->
<link rel="dns-prefetch" href="//">
```


* doctype的作用
1. 告知浏览器的解析器用什么文档标准解析这个文档,  doctype不存在或不正确会导致文档以怪异模式呈现

* 前端渲染和后端渲染的区别
1. 后端渲染优势: 开发速度快, 不涉及前端交互; seo友好度较高, 能够一次性渲染页面, 利于搜索引擎抓取. 劣势: 可维护性差, 因为是一次性渲染页面; 编码效率低, 前后端代码混在一起; 无法进行跨平台开发.
2. 前端渲染优势: 端口分离, 专注于前端; 可维护性高; 跨平台; 响应速度快. 劣势: 不利于seo优化; 首次开发成本较高; 安全性低.

* canvas和svg在绘图有哪些优劣
1. canvas依赖分辨率; 不支持事件处理器; 弱的文本渲染能力; 能够以 .png 或 .jpg 格式保存结果图像; 最适合图像密集型的游戏，其中的许多对象会被频繁重绘
2. 不依赖分辨率; 支持事件处理器; 最适合带有大型渲染区域的应用程序（比如谷歌地图）; 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）; 不适合游戏应用

<!-- more -->

* 常见行内元素, 块级元素, 空(void)元素有哪些?
1. 行内元素: a, b, span, img, input, label, select, strong
2. 块级元素: p, div, h1-h6, ul, li
3. 空元素: 没有内容的 HTML 元素被称为空元素, 是在开始标签中关闭的. br, hr, img, meta, link, input

* HTML5新增了哪些内容或API, 使用过哪些
1. 用于绘图的canvas;
2. 用于媒体的video, audio标签;
3. 语义化更好的article section等标签;
4. 用于表单控件的email, number, date;
5. 针对cookie的不足出现的本地离线存储;
6. API有contextmenu可以自定义右键菜单, 允许获取用户的地理位置getCurrentPosition()


* input和textarea的区别
区别就是一个是只能单行输入, 还有size可以指定input的长度. 一个是多行输入, cols rows指定整个textarea的大小.


* 用一个div模拟textarea的实现
需要用到不常见的html5属性contenteditable, 这是内容可编辑的意思, 
```html
<div contenteditable = 'true'></div>
```
这样div区域内就可以编辑.  
<div contenteditable = 'true'>这一个div可编辑</div>





### CSS

* 纯css实现三角形的方法(三种)
```css
1. border
2. 利用"◆"字符
3. css3旋转div transfrom rotate(45deg)
```



* CSS隐藏元素的几种方法（至少说出三种）
```css
Opacity:元素本身依然占据它自己的位置并对网页的布局起作用。它也将响应用户交互;
Visibility:与 opacity 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏;
Display:display 设为 none 任何对该元素直接打用户交互操作都不可能生效。此外，读屏软件也不会读到元素的内容。这种方式产生的效果就像元素完全不存在;
Position:不会影响布局，能让元素保持可以操作;
```

* CSS清除浮动的几种方法（至少两种）
```css
使用带clear属性的空元素 // 在浮动元素后添加一个空元素div.clear
使用CSS的overflow属性；// 父元素设置overflow: hidden即可
使用CSS的:after伪元素；// 最常见

<div class="news clearfix">
  <img src="news-pic.jpg" />
  <p>some text</p>
</div>

.news img {
  float: left;
}

.news p {
  float: right;
}

.clearfix:after{
  content: "020";
  display: block;
  height: 0;
  clear: both;
  visibility: hidden;
}

.clearfix {
  /* 触发 hasLayout, 兼容 ie6 7  */
  zoom: 1;
}
```

* 页面导入样式时，使用link和@import有什么区别？
1. link属于XHTML标签, 除了加载CSS外, 还能用于定义RSS, 定义rel连接属性等作用; 而@import是CSS提供的, 只能用于加载CSS;
2. 页面被加载的时, link会同时被加载, 而@import引用的CSS会等到页面被加载完再加载;

* 介绍一下CSS的盒子模型？
1. 有两种, IE 盒子模型、标准 W3C 盒子模型; IE的content部分包含了 border 和 padding; width, height = border+padding+content;
2. 盒模型: 内容(content)、填充(padding)、边界(margin)、 边框(border).  width, height = content;


* 左右布局：左边定宽、右边自适应, 不少于3种方法
```css
<aside class='left'></aside>
<section class='right'></section>

aside {
  width: 200px;
  height: 200px;
  background: #f00;
}

section {
  height: 200px;
  background: #0f0;
}

1. 左边左浮动, 右边宽100%
.left {
  float: left;
}
.right {
  width: 100%;
}
2. 父元素flex布局, 右边flex:1
body {
  display: flex;
}
.right {
  flex: 1; // 通过设置 flex 的数值来控制所占空间的比例
}
3. 设置浮动, 用calc给右边宽度
.left, .right {
  float: left;
}
.right {
  width: calc(100% - 200px); // 200px是左边盒子的宽度
}
4. margin负值法 (圣杯/双飞翼)
这里要注意自适应的div要放在前面, 定宽放后面
```

* CSS3用过哪些新特性
动画@keyframes, animation, transtion, box-shadow, text-shadow等, 详情可看我的简述CSS3的一些属性系列

* BFC、IFC
BFC: block formatting context 块级格式化上下文, 即块级作用域 
```css
// 满足以下一项即可成为BFC
float: left | right
position: fixed | absolute
display: inline-block | table-cell | table-caption | flex | inline-flex
overflow: hidden | scroll | auto
```
用BFC来做什么:1.外边距折叠; 2.容器无高度包含浮动元素; 3.阻止文字环绕
IFC:  inline formatting context 内联格式化上下文
用IFC来做什么:1.水平居中: 当一个块要在环境中水平居中时, 设置其为inline-block则会在外层产生IFC, 通过text-align则可以使其水平居中;
2.垂直居中: 创建一个IFC, 用其中一个元素撑开父元素的高度, 然后设置其vertical-align:middle, 其他行内元素则可以在此父元素下垂直居中;

* 对栅格的理解
栅格12列, 为什么取12, 12是1, 2, 3, 4, 6的最小公倍数. 栅格是通过一系列行row和列col-xx-xx的组合来创建页面布局的系统.

* （水平）居中有哪些实现方式
1. 需要居中的元素是块元素的话, 只需要margin: 0 auto;
2. 如果是内联元素, 需要display成内联块, 然后父元素text-align: center即可.

* display:none和visibility:hidden有什么区别
1. 显示区域: display设置为none后不会占据空间, visibility:hidden会保留空间;
2. reflow回流和repaint重绘: display因为改变元素位置, 会触发relow和repaint, visibility没有改变其位置, 只会触发repaint;
3. 子元素的显示: display为none后子元素无论设置什么属性都会被连同隐藏, visibility不同, 其子元素可以用visibility:visible来显示.




### JS



* cookie和session的区别
```JavaScript
1.cookie存在客户端, session存在服务端
2.session依赖session id, 而session id存于cookie, 如果禁用cookie, session也会失效. 除非在url里加session id验证
3.session存放在服务器的文件里, cookie存于浏览器
```

* NodeJS的优缺点
```css
优点：
1. 高并发（最重要的优点）

2. 适合I/O密集型应用

缺点：
1. 不适合CPU密集型应用；CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；

解决方案：分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起；

2. 只支持单核CPU，不能充分利用CPU

3. 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃

原因：单进程，单线程

解决方案：
（1）Nnigx反向代理，负载均衡，开多个进程，绑定多个端口；

（2）开多个进程监听同一个端口，使用cluster模块；

4. 开源组件库质量参差不齐，更新快，向下不兼容

5. Debug不方便，错误没有stack trace
```

* js对象的深度克隆代码实现
```javascript
function clone(Obj) {
    var buf;   
    if (Obj instanceof Array) {
        buf = [];  // 创建一个空的数组
        var i = Obj.length;
        while (i--) {
            buf[i] = clone(Obj[i]);
        }
        return buf;
    } else if (Obj instanceof Object){
        buf = {};  // 创建一个空对象
        for (var k in Obj) {  // 为这个对象添加新的属性
            buf[k] = clone(Obj[k]);
        }
        return buf;
    }else{
        return Obj;
    }
}

```
* js对象的深度克隆代码实现 (2)
```javascript
function deepCopy(p, c) {
  var c = c || {};
  for(var i in p) {
    if(typeof p[i] === 'object') {
      c[i] = (p[i].constructor === Array) ? [] : {};
      deepCopy(p[i], c[i]);
    } else {
      c[i] = p[i];
    }
  }
  return c;
}
```

* js操作获取和设置cookie
```javascript
/*cookie的三种操作：读取，写入，删除*/
var CookieUtil = {
  get:function(name){
    var cookieName = encodeURIComponent(name) + "=",
        cookieStart = document.cookie.indexOf(cookieName),
        cookieValue = null;
    if (cookieStart > -1) {
      var cookieEnd = document.cookie.indexOf(";",cookieStart);
      if (cookieEnd == -1) {
        cookieEnd = document.cookie.length;
      }
      cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length,cookieEnd));
    }
    return cookieValue;
  },
  set:function(name,value,expires,path,domain,secure){
    var cookieText = encodeURIComponent(name) + "=" + encodeURIComponent(value);
    if (expires instanceof Date) {
      cookieText += ";expires=" + expires.toGMTString();
    }
    if (path) {
      cookieText += ";path=" + path;
    }
    if (domain) {
      cookieText += ";domain=" + domain;
    }
    if (secure) {
      cookieText += ";secure";
    }
    document.cookie = cookieText;
  },
  unset:function(name,path,domain,secure){
    this.set(name,"",new Date(0),path,domain,secure);
  }
};
```

* 介绍一下你对浏览器内核的理解？
主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。
渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。
JS引擎则：解析和执行javascript来实现网页的动态效果。  
最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。

* 常见浏览器内核
1. Trident内核: ie
2. Gecko内核: ff
3. Presto内核: Opera7及以上, 现O内核为Blink
4. Webkit内核: Safari, Chrome, 现C内核为Blink

* xss和csrf
1. xss(cross site-scripting)跨站脚本攻击, 在被攻击者的浏览器中执行脚本, 采集被攻击者数据. 如盗用cookie; 以被攻击者的身份执行操作
2. csrf跨站请求伪造. 造成csrf需要两步, 第一登录受信任网站a, 在本地生成cookie, 第二不登出a的情况下访问危险网站b.

* String.prototype.replace()用法. 注意不会改变原字符串, 而是返回新字符串.
1. str.replace(regexp|substr, newStr)
2. str.replace(regexp|substr, function)
```javascript
// substr
var str = 'ac';
str.replace('a', 'b'); // 'bc'

// 1. 
var str = 'Twas the night before Xmas...';
var newstr = str.replace(/xmas/i, 'Christmas');
console.log(newstr);  // Twas the night before Christmas...

// 2.
function styleHyphenFormat(propertyName) {
  function upperToHyphenLower(match) {
    return '-' + match.toLowerCase();
  }
  return propertyName.replace(/[A-Z]/g, upperToHyphenLower);
}
styleHyphenFormat('borderTop'); // border-top
```

* JavaScript的定义 
JavaScript是一种专门为与网页交互而设计的脚本语言。有下列三部分组成 
1. ECMAScript，提供核心语言功能 
2. 文档对象模型（DOM），提供访问与操作网页内容的方法与接口 
3. 浏览器对象模型（BOM），提供与浏览器交互的方法与接口

* javascript的typeof返回哪些数据类型
Object(对象, null) number string function boolean underfind (es6 symbol);

* ajax请求的时候get 和post方式的区别?
1. get方法放在url后面, 不能大于2kb, post方法放在http消息的实体内容发送
2. 安全问题, get安全性低, post安全性高

* 图片懒加载原理
页面加载后只让文档可视区内的图片显示，其它不显示，随着用户对页面的滚动，判断其区域位置，生成img标签，让到可视区的图片加载出来

* 谈谈This对象的理解
1. this是js的一个关键字, 随着函数使用场合不同, this的值会发生变化.
2. 但是有一个总原则, 那就是this指的是调用函数的那个对象.
3. this一般情况下: 是全局对象Global. 作为方法调用, 那么this就是指这个对象

* JSONP原理
ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。

* ajax 的过程是怎样的
1. 创建XMLHttpRequest对象,也就是创建一个异步调用对象
2. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息
3. 设置响应HTTP请求状态变化的函数
4. 发送HTTP请求
5. 获取异步调用返回的数据
6. 使用JavaScript和DOM实现局部刷新

* 详解单页面路由的几种实现原理
1. url完全不动型. 这一种的情况是url完全不动, 即你的页面怎么改变, 怎么跳转url都不会改变, 这种情况的原理就是纯ajax拿到页面后替换原页面中的元素.
2. 带hash(#)型. 这种类型的优点就是刷新页面, 页面也不会丢. 通过监听hash(#)的变化来执行js代码, 从而实现页面的改变. 主要需要用到hashchange事件.
```JavaScript
window.addEventListener('hashchange', () => {
  // 改变节点
})
```
3. 无hash(#)型. 这种类型是通过html5的最新history api来实现的能正常的回退前进. url和普通的url一样, 但缺点就是一刷新页面页面就会丢失. 
```JavaScript
主要需要用到history.pushState,
history.replaceState, // 不会记录到历史栈
history.state,
window.onpopstate事件.
window.addEventListener('popstate', () => {
  // 更新节点
})
```

* js跨域的实现方法原理
1. 通过jsonp. 有个a.html页面, 假设这个json数据地址是http://example.com/data.php
```javascript
// a.html
<script>
function doSomething (jsondata) {
  // 处理获得的data数据
}
</script>
<script src='http://example.com/data.php?callback=doSomething'></script>
// 也可以是php文件返回一个js函数的调用, 如 echo 'doSomething(...)', 这样就不用在url写callback
// jsonp跨域缺点: 只支持get请求, 安全隐患, 必须双方都受信任.
```

2. 通过修改document.domain来跨子域. 比如，有一个页面, 它的地址是http://www.example.com/a.html, 在这个页面里面有一个iframe, 它的src是http://example.com/b.html.
```javascript
// a.html与它里面的iframe框架是不同域的, 无法通过在页面中书写js代码来获取iframe中的东西
<script>
function onLoad () {
  var iframe = document.getElementById('iframe');
  var win = iframe.contentWindow;
  var doc = win.document;  // 获取不到iframe里的document对象
  var name = win.name;     // 获取不到
}
</script>
<iframe id='iframe' src='http://example.com/b.html' onload = 'onLoad()'></iframe>
```
这时候, 只要把http://www.example.com/a.html和http://example.com/b.html的document.domain设成相同的. document.domain只能往自身或更低一级的域. eg: a.b.example.com 可以设成a.b.example.com、b.example.com、example.com中的任意一个, 不能设 c.a.b.example.com.
```javascript
// a.html
<iframe id='iframe' src='http://example.com/b.html' onload = 'onLoad()'></iframe>
<script>
document.domain = 'example.com'
function onLoad() { ... }
</script>

// b.html
<script>
document.domain = 'example.com'
</script>

//domain缺点: 安全性, 当一个页面被攻击后, 另一个有安全隐患; 如果有多个iframe, 就要设置成大家都相同的domain
```
3. window.name. 把需要的值替换成window.name的值. 如 www.example.com/a.html, 需要www.cnblogs.com/data.html里的数据, 需要iframe充当中间人, 来获取data.HTML的数据, a.html再去获取iframe获取到的数据, 这里注意a.html和iframe需要同源即可
```JavaScript
function getData () {
  var iframe = document.getElementById('iframe');
  iframe.onload = function () {
    var data = iframe.contentWindow.name;
    console.log(data);
  }
  iframe.src = 'http://www.example.com/b.html'; // 与a.html同源
}
<iframe id='iframe' src = 'http://www.cnblogs.com/data.html' style='display:none' onload = getData() ></iframe>
// window.name缺点: window.name的值是字符串形式, 最大只能2M左右
```
4. HTML5的window.postMessage(message,targetOrigin)方法. 可以使用它来向其它的window对象发送消息, 无论这个window对象是属于同源或不同源. 该方法的第一个参数message为要发送的消息, 类型只能为字符串; 第二个参数targetOrigin用来限定接收消息的那个window对象所在的域, 如果不想限定域, 可以使用通配符 *
```JavaScript
// a.html
<script>
function onLoad() {
  var iframe = document.getElementById('iframe');
  var win = iframe.contentWindow;
  win.postMessage('hello world', *);
}
</script>
<iframe id='iframe' src='http://www.example.com/b.html' onload = onLoad() ></iframe>

// b.html
<script>
window.onmessage = function (e) {
  e = e || event;
  console.log(e.data)  // hello world
}
</script>
// h5方法缺点: IE6、IE7不支持
```

5. 服务端的方法http请求包含Access-Control-Allow-Origin. 

* 因为引用计数产生的内存泄漏，在ES6中的解决办法是什么？
ES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是弱引用。

* js中基本类型在内存中存储方式是什么，引用类型的存储方式是什么
基本类型在内存中占据固定大小的空间, 因此变量和值都存在栈中, 引用类型的存储方式是栈中存变量和堆内存地址, 堆里面是引用类型. 原因是因为引用类型是可扩展的, 内存可大可小, 内存不能给每一个引用类型都开一个新的空间, 采用指针引用科学很多.

* 渐进增强和优雅降级
渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。  
优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。

* 手写一个jsonp
```javascript
(function (window,document) {
    "use strict";
    var jsonp = function (url,data,callback) {

        // 1.将传入的data数据转化为url字符串形式
        // {id:1,name:'zhangsan'} => id=1&name=zhangsan
        var dataString = url.indexof('?') == -1? '?': '&';
        for(var key in data){
            dataString += key + '=' + data[key] + '&';
        };

        // 2 处理url中的回调函数
        // cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）
        var cbFuncName = 'my_json_cb_' + Math.random().toString().replace('.','');
        dataString += 'callback=' + cbFuncName;

        // 3.创建一个script标签并插入到页面中
        var scriptEle = document.createElement('script');
        scriptEle.src = url + dataString;

        // 4.挂载回调函数
        window[cbFuncName] = function (data) {
            callback(data);
            // 处理完回调函数的数据之后，删除jsonp的script标签
            document.body.removeChild(scriptEle);
        }

        // 5.append到页面中
        document.body.appendChild(scriptEle);
    }

    // 因为jsonp是一个私有函数外部不能调用，所有jsonp函数作文window对象的一个方法，供外部调用
    window.$jsonp = jsonp;

})(window,document)
```


### VUE
* Vue双向数据绑定的实现
vue中有一个observer来观察所有的属性的变化, 一旦有变化, 就会发给watcher, 然后watcher来告诉编译器complie来改变数值

* vue和其他两个框架的区别
1. vue更轻量级, gzip后大小只有20+k, react有40+k, angular有50+k. 移动端vue更适合
2. vue学习曲线平稳, angular入门较难, 概念多, 因为其思想很多沿用后端技术, react需要学很多, 附带全家桶.
3. vue吸收另外两家之长, 既有angular的指令, 也有react的组件化思想.

* vue.js的核心思想
1. 数据驱动
2. 组件化

* 数据响应原理
有一个数据a.b,在vue对象实例化过程中，会给a,b通过ES5的defineProperty()方法，添加getter和setter方法，同时vue.js会对模板做编译，解析生成一个指令对象，比如v-text指令，每个指令对象都会关联一个watcher，当对指令对象求值时，就会触发getter，并将依赖收集到watcher中；当再次改变a.b值时，就会触发setter方法，会通知到对应关联的watcher,watcher则再次对a.b求值，计算对比新旧值，当值改变时，watcher会通知到指令，调用指令的update方法，由于指令是对dom的封装，所以会调用原生dom的方法，去更新视图。

* vue-loader是什么？使用它的用途有哪些？
解析.vue文件的一个加载器，跟template/js/style转换成js模块。
用途：js可以写es6、style样式可以scss或less、template可以加jade等

* vue生命周期总共有几个阶段？
它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后

* 简单描述每个周期具体适合哪些场景？
生命周期钩子的一些使用方法：  
beforecreate : 可以在这加个loading事件，在加载实例时触发  
created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用  
mounted : 挂载元素，获取到DOM节点  
updated : 如果对数据统一处理，在这里写上相应函数  
beforeDestroy : 可以做一个确认停止事件的确认框  
nextTick : 更新数据后立即操作dom



### 移动端bug



* fixed遮罩滚动穿透问题
```JavaScript
// 1.touchmove + preventDefault
mask.addEventListener('touchmove', (e) {
  e.preventDefault()
}, false)
// 缺点, 当弹出层需要滚动时也会被阻止

// 2.position +js保存滚动条位置
// css
.mask {
  position: fixed;
  width: 100%;
}

// js
// 遮罩开启时保存当前滚动位置, 关闭时还原之前滚动位置
```

* 移动设备忽略将页面中的数字识别为电话号码的方法
在head里面加一个
```html
<meta name = 'format-detection' content = 'telephone=no' />
```
即可, 响应的还可以有email=no让邮箱不可点击.

* 上下拉动滚动条时卡顿、慢
```css
body {
  -webkit-overflow-scrolling: touch;
  overflow-scrolling: touch;
}
```

* 禁止复制、选中文本
```css
Element {
  -webkit-user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  user-select: none;
}
```




### 计网



* 在浏览器中输入URL并回车后都发生了什么?
1. 解析URL
2. DNS解析
3. 浏览器与网站建立TCP连接（三次握手）
4. 请求和传输数据
5. 浏览器渲染页面

* http强缓存和协商缓存
所谓的强缓存就是本地缓存. 浏览器第一次请求时, 一定是强缓存, 返回状态码200; 第二次请求时, 会先获取该资源缓存的header信息(cache-control, expires; cache-control与expires同时存在的话，cache-control的优先级高于expires), 两者都符合成立的话就不去服务器请求, 直接拿本地的缓存. 如果上面两个不成立, 就会发送请求到服务器(Etag/if-none-match, Last-modified/if-modified-since; Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。), 由服务器根据请求中的相关header信息来对比结果是否协商缓存成立, 二者如果有一个和服务器上的不一致, 那就重新返回资源, 如果都没变化则返回304 not modified, 浏览器收到304后, 从本地缓存中加载资源.

* HTTP2与1.1区别
1. HTTP2.0采用二进制格式而非文本格式（二进制解析更加高效，错误更少）
2. HTTP2是完全的多路复用（能同时传输多个请求和响应）
3. 使用报头压缩，降低了开销
4. 可以让服务器主动把响应推送到客户端

* HTTP1.0与1.1区别
HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。但是，这也造成了一些性能上的缺陷，例如，一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的URL地址，当WEB浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析WEB服务器返回的该网页文档中的HTML内容时，发现其中的<img>图像标签后，浏览器将根据<img>标签中的src属性所指定的URL地址再次向服务器发出下载图像数据的请求
HTTP 1.1支持持久连接（connection默认keep-alive），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。 在HTTP1.0和HTTP1.1协议中都有对长连接的支持。其中HTTP1.0需要在request中增加”Connection： keep-alive“ header才能够支持，而HTTP1.1默认支持.
HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求（流水线处理），但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。

* HTTP与HTTPS
HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。HTTPS使用不同于HTTP协议的默认端口及一个加密、身份验证层（HTTP与TCP之间）
　　HTTPS和HTTP的区别主要如下：
　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：
　　（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；
　　（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；
　　（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。
　  （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。
　　（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。

客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。（先非对称，在对称）
　　（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。
　　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。
　　（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。
　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
　　（5）Web服务器利用自己的私钥解密出会话密钥。
（6）Web服务器利用会话密钥加密与客户端之间的通信。






### 数据结构



* 两个队列实现一个栈
A队列作为主队列, B队列. 判断A队列长度是否为1, 如果是直接出队列. 如果不是, 出(长度-1)队列到B队列里, 然后最后一个出队列, 依次列推

* 两个栈实现一个队列
入栈都给A栈, 要出栈时判断B栈是否为空, 为空, 将A栈全部pop后, push到B栈, 然后B栈顺序pop. 如果不为空, 将B栈里的先pop.

* 有哪些数据结构
图, 树, 线性, 集合.




### 操作系统





* 线程和进程的区别和联系
线程是 CPU 调度的一个基本单位; 进程是资源分配的基本单位.  
两者的联系: 进程和线程都是操作系统所运行的程序运行的基本单元.  
区别：  
（1）进程具有独立的空间地址，一个进程崩溃后，在保护模式下不会对其它进程产生影响。  
（2）线程只是一个进程的不同执行路径，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉。

