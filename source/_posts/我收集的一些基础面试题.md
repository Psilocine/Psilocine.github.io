---
title: 我收集的一些基础面试题
date: 2017-09-22 16:29:49
tags: [面试, 前端]
---

##### 写在前面

我收集的也有我遇到过的面试题, 会持续更新.

### HTML

- 前端工程化的理解
  模块化、组件化、规范化、自动化

```html
1.模块化 将文件拆分成互相依赖的小文件, 多人协作开发后, 再进行统一的拼装. js模块化 commonjs amd cmd
css模块化 命名风格. 在类前加规范, 如布局(grid)(.g-xxx) 功能(function)(.f-xxx) 2.组件化
每个包含html+css+js完备的单元, 成为组件 3.规范化 目录结构的确定, 前后端接口规范, 组件命名规范
commit描述规范 4.自动化 简单的机械劳动, 让机器帮我们完成. 线上发布 => 使用脚本 图片<20kb =>
webpack转base64
```

- 如何 html 中开启和关闭 dns 预读取

```html
<!-- on打开 off关闭 -->
<meta http-equiv="x-dns-prefetch-control" content="off" />

<!-- 方法二 通过link的rel属性 -->
<link rel="dns-prefetch" href="//" />
```

- doctype 的作用

1. 告知浏览器的解析器用什么文档标准解析这个文档, doctype 不存在或不正确会导致文档以怪异模式呈现

- 前端渲染和后端渲染的区别

1. 后端渲染优势: 开发速度快, 不涉及前端交互; seo 友好度较高, 能够一次性渲染页面, 利于搜索引擎抓取. 劣势: 可维护性差, 因为是一次性渲染页面; 编码效率低, 前后端代码混在一起; 无法进行跨平台开发.
2. 前端渲染优势: 端口分离, 专注于前端; 可维护性高; 跨平台; 响应速度快. 劣势: 不利于 seo 优化; 首次开发成本较高; 安全性低.

- canvas 和 svg 在绘图有哪些优劣

1. canvas 依赖分辨率; 不支持事件处理器; 弱的文本渲染能力; 能够以 .png 或 .jpg 格式保存结果图像; 最适合图像密集型的游戏，其中的许多对象会被频繁重绘
2. svg 不依赖分辨率; 支持事件处理器; 最适合带有大型渲染区域的应用程序（比如谷歌地图）; 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）; 不适合游戏应用

<!-- more -->

- 常见行内元素, 块级元素, 空(void)元素有哪些?

1. 行内元素: a, b, span, img, input, label, select, strong
2. 块级元素: p, div, h1-h6, ul, li
3. 空元素: 没有内容的 HTML 元素被称为空元素, 是在开始标签中关闭的. br, hr, img, meta, link, input

- HTML5 新增了哪些内容或 API, 使用过哪些

1. 用于绘图的 canvas;
2. 用于媒体的 video, audio 标签;
3. 语义化更好的 article section 等标签;
4. 用于表单控件的 email, number, date;
5. 针对 cookie 的不足出现的本地离线存储;
6. API 有 contextmenu 可以自定义右键菜单, 允许获取用户的地理位置 getCurrentPosition()

- input 和 textarea 的区别
  区别就是一个是只能单行输入, 还有 size 可以指定 input 的长度. 一个是多行输入, cols rows 指定整个 textarea 的大小.

* 用一个 div 模拟 textarea 的实现
  需要用到不常见的 html5 属性 contenteditable, 这是内容可编辑的意思,

```html
<div contenteditable="true"></div>
```

这样 div 区域内就可以编辑.

<div contenteditable = 'true'>这一个div可编辑</div>

### CSS

- 纯 css 实现三角形的方法(三种)

```css
1. border
2. 利用"◆"字符
3. css3旋转div transfrom rotate(45deg)
```

- CSS 隐藏元素的几种方法（至少说出三种）

```css
opacity: 元素本身依然占据它自己的位置并对网页的布局起作用。它也将响应用户交互;
visibility: 与 opacity 唯一不同的是它不会响应任何用户交互。此外，元素在读屏软件中也会被隐藏;
display: display 设为 none
  任何对该元素直接打用户交互操作都不可能生效。此外，读屏软件也不会读到元素的内容。这种方式产生的效果就像元素完全不存在;
position: 不会影响布局，能让元素保持可以操作;
```

- CSS 清除浮动的几种方法（至少两种）

```css
使用带clear属性的空元素 // 在浮动元素后添加一个空元素div.clear
使用CSS的overflow属性；// 父元素设置overflow: hidden即可
使用CSS的:after伪元素；// 最常见

<div class="news clearfix">
  <img src="news-pic.jpg" />
  <p>some text</p>
</div>

.news img {
  float: left;
}

.news p {
  float: right;
}

.clearfix:after {
  content: "020";
  display: block;
  height: 0;
  clear: both;
  visibility: hidden;
}

.clearfix {
  /* 触发 hasLayout, 兼容 ie6 7  */
  zoom: 1;
}
```

- 页面导入样式时，使用 link 和@import 有什么区别？

1. link 属于 XHTML 标签, 除了加载 CSS 外, 还能用于定义 RSS, 定义 rel 连接属性等作用; 而@import 是 CSS 提供的, 只能用于加载 CSS;
2. 页面被加载的时, link 会同时被加载, 而@import 引用的 CSS 会等到页面被加载完再加载;

- 介绍一下 CSS 的盒子模型？

1. 有两种, IE 盒子模型、标准 W3C 盒子模型; IE 的 content 部分包含了 border 和 padding; width, height = border+padding+content;
2. 盒模型: 内容(content)、填充(padding)、边界(margin)、 边框(border). width, height = content;

- 左右布局：左边定宽、右边自适应, 不少于 3 种方法

```css
<aside class='left'></aside>
<section class='right'></section>

aside {
  width: 200px;
  height: 200px;
  background: #f00;
}

section {
  height: 200px;
  background: #0f0;
}

1. 左边左浮动, 右边宽100%
.left {
  float: left;
}
.right {
  width: 100%;
}
2. 父元素flex布局, 右边flex:1
body {
  display: flex;
}
.right {
  flex: 1; // 通过设置 flex 的数值来控制所占空间的比例
}
3. 设置浮动, 用calc给右边宽度
.left, .right {
  float: left;
}
.right {
  width: calc(100% - 200px); // 200px是左边盒子的宽度
}
4. margin负值法 (圣杯/双飞翼)
这里要注意自适应的div要放在前面, 定宽放后面
```

- CSS3 用过哪些新特性
  动画@keyframes, animation, transtion, box-shadow, text-shadow 等, 详情可看我的简述 CSS3 的一些属性系列

- BFC、IFC
  BFC: block formatting context 块级格式化上下文, 即块级作用域

```css
// 满足以下一项即可成为BFC
float: left | right
position: fixed | absolute
display: inline-block | table-cell | table-caption | flex | inline-flex
overflow: hidden | scroll | auto
```

用 BFC 来做什么:1.外边距折叠; 2.容器无高度包含浮动元素; 3.阻止文字环绕
IFC: inline formatting context 内联格式化上下文
用 IFC 来做什么:1.水平居中: 当一个块要在环境中水平居中时, 设置其为 inline-block 则会在外层产生 IFC, 通过 text-align 则可以使其水平居中; 2.垂直居中: 创建一个 IFC, 用其中一个元素撑开父元素的高度, 然后设置其 vertical-align:middle, 其他行内元素则可以在此父元素下垂直居中;

- 对栅格的理解
  栅格 12 列, 为什么取 12, 12 是 1, 2, 3, 4, 6 的最小公倍数. 栅格是通过一系列行 row 和列 col-xx-xx 的组合来创建页面布局的系统.

- （水平）居中有哪些实现方式

1. 需要居中的元素是块元素的话, 只需要 margin: 0 auto;
2. 如果是内联元素, 需要 display 成内联块, 然后父元素 text-align: center 即可.

- display:none 和 visibility:hidden 有什么区别

1. 显示区域: display 设置为 none 后不会占据空间, visibility:hidden 会保留空间;
2. reflow 回流和 repaint 重绘: display 因为改变元素位置, 会触发 relow 和 repaint, visibility 没有改变其位置, 只会触发 repaint;
3. 子元素的显示: display 为 none 后子元素无论设置什么属性都会被连同隐藏, visibility 不同, 其子元素可以用 visibility:visible 来显示.

### JS

- cookie 和 session 的区别

```JavaScript
1.cookie存在客户端, session存在服务端
2.session依赖session id, 而session id存于cookie, 如果禁用cookie, session也会失效. 除非在url里加session id验证
3.session存放在服务器的文件里, cookie存于浏览器
```

- NodeJS 的优缺点

```css
优点：
1. 高并发（最重要的优点）

2. 适合I/O密集型应用

缺点：
1. 不适合CPU密集型应用；CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；

解决方案：分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起；

2. 只支持单核CPU，不能充分利用CPU

3. 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃

原因：单进程，单线程

解决方案：
（1）Nnigx反向代理，负载均衡，开多个进程，绑定多个端口；

（2）开多个进程监听同一个端口，使用cluster模块；

4. 开源组件库质量参差不齐，更新快，向下不兼容

5. Debug不方便，错误没有stack trace
```

- js 对象的深度克隆代码实现

```javascript
function clone(Obj) {
  var buf;
  if (Obj instanceof Array) {
    buf = []; // 创建一个空的数组
    var i = Obj.length;
    while (i--) {
      buf[i] = clone(Obj[i]);
    }
    return buf;
  } else if (Obj instanceof Object) {
    buf = {}; // 创建一个空对象
    for (var k in Obj) {
      // 为这个对象添加新的属性
      buf[k] = clone(Obj[k]);
    }
    return buf;
  } else {
    return Obj;
  }
}
```

- js 对象的深度克隆代码实现 (2)

```javascript
function deepCopy(p, c) {
  var c = c || {};
  for (var i in p) {
    if (typeof p[i] === "object") {
      c[i] = p[i].constructor === Array ? [] : {};
      deepCopy(p[i], c[i]);
    } else {
      c[i] = p[i];
    }
  }
  return c;
}
```

- js 操作获取和设置 cookie

```javascript
/*cookie的三种操作：读取，写入，删除*/
var CookieUtil = {
  get: function(name) {
    var cookieName = encodeURIComponent(name) + "=",
      cookieStart = document.cookie.indexOf(cookieName),
      cookieValue = null;
    if (cookieStart > -1) {
      var cookieEnd = document.cookie.indexOf(";", cookieStart);
      if (cookieEnd == -1) {
        cookieEnd = document.cookie.length;
      }
      cookieValue = decodeURIComponent(
        document.cookie.substring(cookieStart + cookieName.length, cookieEnd)
      );
    }
    return cookieValue;
  },
  set: function(name, value, expires, path, domain, secure) {
    var cookieText = encodeURIComponent(name) + "=" + encodeURIComponent(value);
    if (expires instanceof Date) {
      cookieText += ";expires=" + expires.toGMTString();
    }
    if (path) {
      cookieText += ";path=" + path;
    }
    if (domain) {
      cookieText += ";domain=" + domain;
    }
    if (secure) {
      cookieText += ";secure";
    }
    document.cookie = cookieText;
  },
  unset: function(name, path, domain, secure) {
    this.set(name, "", new Date(0), path, domain, secure);
  }
};
```

- 介绍一下你对浏览器内核的理解？
  主要分成两部分：渲染引擎(layout engineer 或 Rendering Engine)和 JS 引擎。
  渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。
  JS 引擎则：解析和执行 javascript 来实现网页的动态效果。  
  最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。

- 常见浏览器内核

1. Trident 内核: ie
2. Gecko 内核: ff
3. Presto 内核: Opera7 及以上, 现 O 内核为 Blink
4. Webkit 内核: Safari, Chrome, 现 C 内核为 Blink

- xss 和 csrf

1. xss(cross site-scripting)跨站脚本攻击, 在被攻击者的浏览器中执行脚本, 采集被攻击者数据. 如盗用 cookie; 以被攻击者的身份执行操作
2. csrf 跨站请求伪造. 造成 csrf 需要两步, 第一登录受信任网站 a, 在本地生成 cookie, 第二不登出 a 的情况下访问危险网站 b.

- String.prototype.replace()用法. 注意不会改变原字符串, 而是返回新字符串.

1. str.replace(regexp|substr, newStr)
2. str.replace(regexp|substr, function)

```javascript
// substr
var str = "ac";
str.replace("a", "b"); // 'bc'

// 1.
var str = "Twas the night before Xmas...";
var newstr = str.replace(/xmas/i, "Christmas");
console.log(newstr); // Twas the night before Christmas...

// 2.
function styleHyphenFormat(propertyName) {
  function upperToHyphenLower(match) {
    return "-" + match.toLowerCase();
  }
  return propertyName.replace(/[A-Z]/g, upperToHyphenLower);
}
styleHyphenFormat("borderTop"); // border-top
```

- JavaScript 的定义
  JavaScript 是一种专门为与网页交互而设计的脚本语言。有下列三部分组成

1. ECMAScript，提供核心语言功能
2. 文档对象模型（DOM），提供访问与操作网页内容的方法与接口
3. 浏览器对象模型（BOM），提供与浏览器交互的方法与接口

- javascript 的 typeof 返回哪些数据类型
  Object(对象, null) number string function boolean underfind (es6 symbol);

- ajax 请求的时候 get 和 post 方式的区别?

1. get 方法放在 url 后面, 不能大于 2kb, post 方法放在 http 消息的实体内容发送
2. 安全问题, get 安全性低, post 安全性高

- 图片懒加载原理
  页面加载后只让文档可视区内的图片显示，其它不显示，随着用户对页面的滚动，判断其区域位置，生成 img 标签，让到可视区的图片加载出来

- 谈谈 This 对象的理解

1. this 是 js 的一个关键字, 随着函数使用场合不同, this 的值会发生变化.
2. 但是有一个总原则, 那就是 this 指的是调用函数的那个对象.
3. this 一般情况下: 是全局对象 Global. 作为方法调用, 那么 this 就是指这个对象

- JSONP 原理
  ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。

- ajax 的过程是怎样的

1. 创建 XMLHttpRequest 对象,也就是创建一个异步调用对象
2. 创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息
3. 设置响应 HTTP 请求状态变化的函数
4. 发送 HTTP 请求
5. 获取异步调用返回的数据
6. 使用 JavaScript 和 DOM 实现局部刷新

- 详解单页面路由的几种实现原理

1. url 完全不动型. 这一种的情况是 url 完全不动, 即你的页面怎么改变, 怎么跳转 url 都不会改变, 这种情况的原理就是纯 ajax 拿到页面后替换原页面中的元素.
2. 带 hash(#)型. 这种类型的优点就是刷新页面, 页面也不会丢. 通过监听 hash(#)的变化来执行 js 代码, 从而实现页面的改变. 主要需要用到 hashchange 事件.

```JavaScript
window.addEventListener('hashchange', () => {
  // 改变节点
})
```

3. 无 hash(#)型. 这种类型是通过 html5 的最新 history api 来实现的能正常的回退前进. url 和普通的 url 一样, 但缺点就是一刷新页面页面就会丢失.

```JavaScript
主要需要用到history.pushState,
history.replaceState, // 不会记录到历史栈
history.state,
window.onpopstate事件.
window.addEventListener('popstate', () => {
  // 更新节点
})
```

- js 跨域的实现方法原理

1. 通过 jsonp. 有个 a.html 页面, 假设这个 json 数据地址是http://example.com/data.php

```javascript
// a.html
<script>
function doSomething (jsondata) {
  // 处理获得的data数据
}
</script>
<script src='http://example.com/data.php?callback=doSomething'></script>
// 也可以是php文件返回一个js函数的调用, 如 echo 'doSomething(...)', 这样就不用在url写callback
// jsonp跨域缺点: 只支持get请求, 安全隐患, 必须双方都受信任.
```

2. 通过修改 document.domain 来跨子域. 比如，有一个页面, 它的地址是http://www.example.com/a.html, 在这个页面里面有一个 iframe, 它的 src 是http://example.com/b.html.

```javascript
// a.html与它里面的iframe框架是不同域的, 无法通过在页面中书写js代码来获取iframe中的东西
<script>
function onLoad () {
  var iframe = document.getElementById('iframe');
  var win = iframe.contentWindow;
  var doc = win.document;  // 获取不到iframe里的document对象
  var name = win.name;     // 获取不到
}
</script>
<iframe id='iframe' src='http://example.com/b.html' onload = 'onLoad()'></iframe>
```

这时候, 只要把http://www.example.com/a.html和http://example.com/b.html的document.domain设成相同的. document.domain 只能往自身或更低一级的域. eg: a.b.example.com 可以设成 a.b.example.com、b.example.com、example.com 中的任意一个, 不能设 c.a.b.example.com.

```javascript
// a.html
<iframe id='iframe' src='http://example.com/b.html' onload = 'onLoad()'></iframe>
<script>
document.domain = 'example.com'
function onLoad() { ... }
</script>

// b.html
<script>
document.domain = 'example.com'
</script>

//domain缺点: 安全性, 当一个页面被攻击后, 另一个有安全隐患; 如果有多个iframe, 就要设置成大家都相同的domain
```

3. window.name. 把需要的值替换成 window.name 的值. 如 www.example.com/a.html, 需要 www.cnblogs.com/data.html 里的数据, 需要 iframe 充当中间人, 来获取 data.HTML 的数据, a.html 再去获取 iframe 获取到的数据, 这里注意 a.html 和 iframe 需要同源即可

```JavaScript
function getData () {
  var iframe = document.getElementById('iframe');
  iframe.onload = function () {
    var data = iframe.contentWindow.name;
    console.log(data);
  }
  iframe.src = 'http://www.example.com/b.html'; // 与a.html同源
}
<iframe id='iframe' src = 'http://www.cnblogs.com/data.html' style='display:none' onload = getData() ></iframe>
// window.name缺点: window.name的值是字符串形式, 最大只能2M左右
```

4. HTML5 的 window.postMessage(message,targetOrigin)方法. 可以使用它来向其它的 window 对象发送消息, 无论这个 window 对象是属于同源或不同源. 该方法的第一个参数 message 为要发送的消息, 类型只能为字符串; 第二个参数 targetOrigin 用来限定接收消息的那个 window 对象所在的域, 如果不想限定域, 可以使用通配符 \*

```JavaScript
// a.html
<script>
function onLoad() {
  var iframe = document.getElementById('iframe');
  var win = iframe.contentWindow;
  win.postMessage('hello world', *);
}
</script>
<iframe id='iframe' src='http://www.example.com/b.html' onload = onLoad() ></iframe>

// b.html
<script>
window.onmessage = function (e) {
  e = e || event;
  console.log(e.data)  // hello world
}
</script>
// h5方法缺点: IE6、IE7不支持
```

5. 服务端的方法 http 请求包含 Access-Control-Allow-Origin.

- 因为引用计数产生的内存泄漏，在 ES6 中的解决办法是什么？
  ES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是弱引用。

- js 中基本类型在内存中存储方式是什么，引用类型的存储方式是什么
  基本类型在内存中占据固定大小的空间, 因此变量和值都存在栈中, 引用类型的存储方式是栈中存变量和堆内存地址, 堆里面是引用类型. 原因是因为引用类型是可扩展的, 内存可大可小, 内存不能给每一个引用类型都开一个新的空间, 采用指针引用科学很多.

- 渐进增强和优雅降级
  渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。  
  优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。

- 手写一个 jsonp

```javascript
(function(window, document) {
  "use strict";
  var jsonp = function(url, data, callback) {
    // 1.将传入的data数据转化为url字符串形式
    // {id:1,name:'zhangsan'} => id=1&name=zhangsan
    var dataString = url.indexof("?") == -1 ? "?" : "&";
    for (var key in data) {
      dataString += key + "=" + data[key] + "&";
    }

    // 2 处理url中的回调函数
    // cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）
    var cbFuncName =
      "my_json_cb_" +
      Math.random()
        .toString()
        .replace(".", "");
    dataString += "callback=" + cbFuncName;

    // 3.创建一个script标签并插入到页面中
    var scriptEle = document.createElement("script");
    scriptEle.src = url + dataString;

    // 4.挂载回调函数
    window[cbFuncName] = function(data) {
      callback(data);
      // 处理完回调函数的数据之后，删除jsonp的script标签
      document.body.removeChild(scriptEle);
    };

    // 5.append到页面中
    document.body.appendChild(scriptEle);
  };

  // 因为jsonp是一个私有函数外部不能调用，所有jsonp函数作文window对象的一个方法，供外部调用
  window.$jsonp = jsonp;
})(window, document);
```

### VUE

- Vue 双向数据绑定的实现
  vue 中有一个 observer 来观察所有的属性的变化, 一旦有变化, 就会发给 watcher, 然后 watcher 来告诉编译器 complie 来改变数值

- vue 和其他两个框架的区别

1. vue 更轻量级, gzip 后大小只有 20+k, react 有 40+k, angular 有 50+k. 移动端 vue 更适合
2. vue 学习曲线平稳, angular 入门较难, 概念多, 因为其思想很多沿用后端技术, react 需要学很多, 附带全家桶.
3. vue 吸收另外两家之长, 既有 angular 的指令, 也有 react 的组件化思想.

- vue.js 的核心思想

1. 数据驱动
2. 组件化

- 数据响应原理
  有一个数据 a.b,在 vue 对象实例化过程中，会给 a,b 通过 ES5 的 defineProperty()方法，添加 getter 和 setter 方法，同时 vue.js 会对模板做编译，解析生成一个指令对象，比如 v-text 指令，每个指令对象都会关联一个 watcher，当对指令对象求值时，就会触发 getter，并将依赖收集到 watcher 中；当再次改变 a.b 值时，就会触发 setter 方法，会通知到对应关联的 watcher,watcher 则再次对 a.b 求值，计算对比新旧值，当值改变时，watcher 会通知到指令，调用指令的 update 方法，由于指令是对 dom 的封装，所以会调用原生 dom 的方法，去更新视图。

- vue-loader 是什么？使用它的用途有哪些？
  解析.vue 文件的一个加载器，跟 template/js/style 转换成 js 模块。
  用途：js 可以写 es6、style 样式可以 scss 或 less、template 可以加 jade 等

- vue 生命周期总共有几个阶段？
  它可以总共分为 8 个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后

- 简单描述每个周期具体适合哪些场景？
  生命周期钩子的一些使用方法：  
  beforecreate : 可以在这加个 loading 事件，在加载实例时触发  
  created : 初始化完成时的事件写在这里，如在这结束 loading 事件，异步请求也适宜在这里调用  
  mounted : 挂载元素，获取到 DOM 节点  
  updated : 如果对数据统一处理，在这里写上相应函数  
  beforeDestroy : 可以做一个确认停止事件的确认框  
  nextTick : 更新数据后立即操作 dom

### 移动端 bug

- fixed 遮罩滚动穿透问题

```JavaScript
// 1.touchmove + preventDefault
mask.addEventListener('touchmove', (e) {
  e.preventDefault()
}, false)
// 缺点, 当弹出层需要滚动时也会被阻止

// 2.position +js保存滚动条位置
// css
.mask {
  position: fixed;
  width: 100%;
}

// js
// 遮罩开启时保存当前滚动位置, 关闭时还原之前滚动位置
```

- 移动设备忽略将页面中的数字识别为电话号码的方法
  在 head 里面加一个

```html
<meta name="format-detection" content="telephone=no" />
```

即可, 响应的还可以有 email=no 让邮箱不可点击.

- 上下拉动滚动条时卡顿、慢

```css
body {
  -webkit-overflow-scrolling: touch;
  overflow-scrolling: touch;
}
```

- 禁止复制、选中文本

```css
element {
  -webkit-user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  user-select: none;
}
```

### 计网

- 在浏览器中输入 URL 并回车后都发生了什么?

1. 解析 URL
2. DNS 解析
3. 浏览器与网站建立 TCP 连接（三次握手）
4. 请求和传输数据
5. 浏览器渲染页面

- http 强缓存和协商缓存
  所谓的强缓存就是本地缓存. 浏览器第一次请求时, 一定是强缓存, 返回状态码 200; 第二次请求时, 会先获取该资源缓存的 header 信息(cache-control, expires; cache-control 与 expires 同时存在的话，cache-control 的优先级高于 expires), 两者都符合成立的话就不去服务器请求, 直接拿本地的缓存. 如果上面两个不成立, 就会发送请求到服务器(Etag/if-none-match, Last-modified/if-modified-since; Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。), 由服务器根据请求中的相关 header 信息来对比结果是否协商缓存成立, 二者如果有一个和服务器上的不一致, 那就重新返回资源, 如果都没变化则返回 304 not modified, 浏览器收到 304 后, 从本地缓存中加载资源.

- HTTP2 与 1.1 区别

1. HTTP2.0 采用二进制格式而非文本格式（二进制解析更加高效，错误更少）
2. HTTP2 是完全的多路复用（能同时传输多个请求和响应）
3. 使用报头压缩，降低了开销
4. 可以让服务器主动把响应推送到客户端

- HTTP1.0 与 1.1 区别
  HTTP 1.0 规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。但是，这也造成了一些性能上的缺陷，例如，一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的 URL 地址，当 WEB 浏览器访问这个网页文件时，浏览器首先要发出针对该网页文件的请求，当浏览器解析 WEB 服务器返回的该网页文档中的 HTML 内容时，发现其中的<img>图像标签后，浏览器将根据<img>标签中的 src 属性所指定的 URL 地址再次向服务器发出下载图像数据的请求
  HTTP 1.1 支持持久连接（connection 默认 keep-alive），在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。  在 HTTP1.0 和 HTTP1.1 协议中都有对长连接的支持。其中 HTTP1.0 需要在 request 中增加”Connection： keep-alive“ header 才能够支持，而 HTTP1.1 默认支持.
  HTTP 1.1 还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求（流水线处理），但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。

- HTTP 与 HTTPS
  HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了 SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了 HTTPS。简单来说，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全。HTTPS 使用不同于 HTTP 协议的默认端口及一个加密、身份验证层（HTTP 与 TCP 之间）
  　　 HTTPS 和 HTTP 的区别主要如下：
  　　 1、https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。
  　　 2、http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。
  　　 3、http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
  　　 4、http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。

虽然说 HTTPS 有很大的优势，但其相对来说，还是存在不足之处的：
　　（1）HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10%到 20%的耗电；
　　（2）HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；
　　（3）SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。
　 （4）SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。
　　（5）HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。

客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤，如图所示。（先非对称，在对称）
　　（1）客户使用 https 的 URL 访问 Web 服务器，要求与 Web 服务器建立 SSL 连接。
　　（2）Web 服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。
　　（3）客户端的浏览器与 Web 服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级。
　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
　　（5）Web 服务器利用自己的私钥解密出会话密钥。
（6）Web 服务器利用会话密钥加密与客户端之间的通信。

### 数据结构

- 两个队列实现一个栈
  A 队列作为主队列, B 队列. 判断 A 队列长度是否为 1, 如果是直接出队列. 如果不是, 出(长度-1)队列到 B 队列里, 然后最后一个出队列, 依次列推

- 两个栈实现一个队列
  入栈都给 A 栈, 要出栈时判断 B 栈是否为空, 为空, 将 A 栈全部 pop 后, push 到 B 栈, 然后 B 栈顺序 pop. 如果不为空, 将 B 栈里的先 pop.

- 有哪些数据结构
  图, 树, 线性, 集合.

### 操作系统

- 线程和进程的区别和联系
  线程是 CPU 调度的一个基本单位; 进程是资源分配的基本单位.  
  两者的联系: 进程和线程都是操作系统所运行的程序运行的基本单元.  
  区别：  
  （1）进程具有独立的空间地址，一个进程崩溃后，在保护模式下不会对其它进程产生影响。  
  （2）线程只是一个进程的不同执行路径，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉。
