---
title: 2019年面试总结
date: 2019-08-27 09:59:09
tags: [前端, 随笔, 面试]
---
##### 写在前面
绝不推荐脱产寻找工作机会, 特别是非一线城市(具有时效性). 笔者始终觉得, 面试是快速提升个人实力的有效方式, 但是面试的状态真的是又累又焦虑, 也是笔者第一次经历社招, 深深觉得社招对工作年限的严格性, 有个工作3年的同事也在找工作(笔者工作1年), 但是他的面试机会比我多一倍不止, 能力虽有差距, 但是他分享的面经发现笔者能答上大部分, 着实难受. 本文记下近期面试的印象深刻的题

#### JavaScript基础
##### 设计模式: 了解单例和工厂吗 应用场景是什么
1. 单例模式(Singleton)的特点是只有一个实例对象, 且该类能自行创建这个实例的一种模式, 单例类对外提供一个访问该单例的全局访问点
```JavaScript
var createWindow = function() {
    var div;
    return function () {
        if (!div) {
            div = document.createElement('div');
            div.innerHTML = 'a toast';
            div.style.display = 'none';
            // ...
            document.body.appendChild(div);
        }
        return div;
    }
}
document.getElementById('id').onclick = function () {
    var win = createWindow();
    win.style.display = 'block';
}
// 点击创建并展示弹窗, 关闭时移除弹窗dom, 频繁dom操作影响性能, 单例只实例化一次
```
应用场景: 某类只要求生成一个对象的时候; 对象需要被共享的时候; 某类频繁实例化和频繁被销毁的时候;
<!-- more -->
2. 工厂方法模式是一类产品的生产模式, 我们把被创建的对象称为"产品", 把创建产品的对象成为"工厂", 特点是用户只需要知道具体工厂的名称就可以得到所要的产品, 无需知道产品的具体创建过程;
工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成
```html
抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。
具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
具体产品（Concrete Product）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。
```
应用场景: 只知道创建产品的工厂名, 不知道具体的产品名; 创建对象的任务由多个子工厂的某一个完成, 而抽象工厂只提供创建产品的接口; 客户不关心创建产品的细节, 只关心产品的品牌;

3. 抽象工厂模式可生产多维度的产品, 特点除了工厂方法模式的特点还有当增加一个新的产品族时不需要修改原代码, 满足开闭原则
在工厂方法模式的具体工厂实现多个产品的生成方法
应用场景: 需要创建的对象是一系列相关联或相依赖的产品族时, 如电器工厂的电视机洗衣机; 系统提供产品的类库, 且所有产品的接口相同, 客户端不依赖产品实例的创建细节和内部结构

##### es5和es6是如何继承的
```JavaScript
// es5
// 原型链实现继承: 利用原型让一个引用类型继承另一个引用类型的属性和方法
// 缺点是引用类型的值会被所以实例共享; 创造子类的实例不能向超类构造函数中传递参数
function Super() {
    this.property = true;
}
Super.prototype.getSuperValue = function () {
    return this.property;
}
function Sub() {
    this.subproperty = false;
}
Sub.prototype = new Super();
Sub.prototype.getSubValue = function () {
    return this.subproperty;
}
var sub = new Sub();
sub.getSuperValue; // true
// 借用构造函数: 在子类构造函数的内部调用超类的构造函数, 通过apply或call来修改作用域, 能够传递参数
// 缺点是方法都在构造函数中定义, 函数无法复用; 在超类定义的方法, 子类不可见
function Super () {
    this.property = true;
}
function Sub() {
    Super.call(this)
}
var sub1 = new Sub();
var sub2 = new Sub();
sub1.property = false;
sub1.property; // false
sub2.property; // true
// 组合继承: 讲原型链和借用构造函数组合, 原型链实现了原型属性和方法的继承, 借用构造函数实现了实例属性的继承, 函数复用, 又保证属性不会被实例共享
// 缺点是调用两次超类构造函数, 一次在创建子类原型的时候, 一次是子类构造函数的内部
function Super (name) {
    this.property = true;
    this.name = name;
}
Super.prototype.sayName = function () {
    console.log('name: ', this.name);
}
function Sub (name, age) {
    Super.call(this, name); // 参数不固定可以用apply
    this.age = age;
}

Sub.prototype = new Super();
Sub.prototype.constructor = Sub;
Sub.prototype.sayAge = function () {
    console.log('age: ', this.age);
}

var sub = new Sub('PsiloLau', 18);
sub.sayName(); // name: PsiloLau
sub.sayAge(); // age: 18
// 寄生组合式继承: 通过借用构造函数来继承属性, 是最理想的继承方式
function object(o) {
    function F() {}
    F.prototype = o;
    return new F();
}
function inheritPrototype(Sub, Super) {
    var prototype = object(Super.prototype);
    prototype.constructor = Sub;
    Sub.prototype = prototype
}
function Super (name) {
    this.name = name;
    this.colors = ['red', 'green'];
}
Super.prototype.sayName = function () {
    console.log(this.name);
}
function Sub (name, age) {
    Super.call(this, name);
    this.age = age;
}
inheritPrototype(Sub, Super);

Sub.prototype.sayAge = function () {
    console.log(this.age);
}
// es6 class与extends实现继承, 本质是es5修改原型链实现继承的语法糖
class Animal {
    constructor (props) {
        this.name = props.name || 'Animal'
    }
    eat () {
        console.log(this.name + ' can eat');
    }
    sleep () {
        console.log(this.name + ' can sleep');
    }
}

class Bird extends Animal {
    constructor (props, ownClass) {
        super(props); // 相对于获得父类的this指向
        this.type = props.type || 'Egg animal';
        this.class = ownClass
    }
    fly () {
        console.log(this.name + ' can fly');
    }
    eat () {
        console.log(this.name + ' can eat worms') // 父类方法重写
    }
}

var swollow = new Bird({
    name: '小燕子',
    type: 'Egg animal'
}, 'Bird class')
swollow.fly(); // 小燕子 can fly
swollow.sleep(); // 小燕子 can sleep
swollow.eat(); // 小燕子 can eat worms
```

##### 原生JavaScript设计组件
todo

##### jsonp工作原理, 为什么不是真正的ajax
原理: 利用script标签没有跨域限制的特性来达到与第三方通讯的目的, 需要通讯时创建script标签指向第三方api地址, 并提供一个回调函数来接受数据(函数名可约定, 也可通过参数传递), 客户端通过调用回调函数来进行交互.
为什么不是真正的ajax: ajax的核心的通过xmlHttpRequest获取内容, jsonp的核心是动态添加; jsonp只支持get请求; ajax不一定要用json格式来传递数据

##### requestAnimationFrame原理
正常显示器刷新频率是60Hz, 即我们看到的显示图像每秒60次的频率刷新. setTimeout通过设置一个间隔时间来不断改变图像位置从而达到动画效果, 但是setTimeout的执行步调和屏幕的刷新步调不一致会导致丢帧现象, requestAnimationFrame的优势就是由系统来决定回调函数的执行步调, 60Hz的显示器就是1000 / 60 = 16.7ms被执行一次, 75Hz的显示器就是13.3ms
```JavaScript
var progress = 0;

function render () {
    progress += 1;

    if (progress < 100) {
        // 条件递归渲染
        window.requestAnimationFrame(render);
    }
}

window.requestAnimationFrame(render);
// cpu节能: setTimeout实现的动画即使页面被最小化或者切换其他标签的时候, 当前页面仍会执行动画任务, requestAnimationFrame只有在激活状态才会执行
// 函数节流: 一个刷新间隔内执行多次函数没有意义
// 缺点: 在低版本安卓下并不友好, github有提供的polyfill, 优先使用高级特效requestAnimationFrame, 后优雅降级
```

##### ['1','2','3'].map(parseInt)的输出, 为什么
```html
输出: [1, NaN, NaN]
原因: parseInt()函数可传两个参数, parseInt(string, radix)
string: 必需, 要解析的字符串.
radix: 可选, 表示要解析的数字的基数, 基于2~36之间, 不填默认为10进制, 小于2或大于36都会返回NaN. 
map()可传三个参数, map(item, index, arr)
item: 必需, 当前元素的值
index: 可选, 当前元素的索引值
arr: 可选, 当前元素属于的数组对象
['1', '2', '3'].map(parseInt) => parseInt('1', 0) (arr是第三个参数, 但是parseInt只接收两个, 所以无效) parseInt('2', 1) parseInt('3', 2) 所以是1, NaN, NaN
```

#### 浏览器
##### 预检请求options作用
在CORS中, 可以使用options方法发起一个预检请求, 以检测实际请求是否可以被服务器所接受. 在某些情况下会发起一次options请求, 当options请求成功返回后, 真正的ajax请求才会发起
```html
某些情况:
1. 跨域请求
2. 自定义请求头
3. 请求头中的content-type是application/x-www-form-urlencoded、multipart/form-data、text/plain以外的格式(默认情况下axios会将JavaScript对象序列化为JSON来发送, 即content-type赋值成application/json)
满足 12 或 13 就会发送options请求
```

##### 对缓存的理解
浏览器每次发起请求, 都会先在浏览器缓存中查找该请求的结果以及缓存标识, 每次拿到返回的请求结果都会将该结果和缓存标识(Last-Modified Etag)存入浏览器缓存中
1. 浏览器没有缓存, 向服务器发起请求, 会在请求头上加上Expires和Cache-Control, 返回200ok和响应结果以及缓存标识, 存入缓存
Expires是http/1的产物, 受限于本地时间, 如果修改了本地时间, 可能会造成缓存失效; Cache-Control是http/1.1的规则, 设置max-age=300时代表这个请求正确返回时间的5分钟内再次加载资源会命中缓存. Cache-Control优先级高于Expires
2. 浏览器在缓存中查找, Cache-Control没有过期, 直接从disk或memory读取资源, 即强缓存
3. 浏览器在缓存中查找, 如果过期了, 向服务器发起请求, 携带标识If-Modified-Since和If-None-Match, 其中之一没有命中意味着资源有更新, 协商缓存失败, 返回200 重新返回资源和缓存标识, 存入浏览器缓存中; 都命中意味资源无更新, 协商缓存成功返回304, 继续使用缓存.
服务器校验优先考虑Etag, 精度上Etag优于Last-Modified, 性能上Etag要差于后者

#### Vue
##### Vue原理详细阐述
主要有Observer、Watcher、Compile、Dep等模块, Vue初始化时调用reactive, 就是Observer用Object.defineProperty重写getter setter来监听属性变化, 在getter里添加订阅者(订阅器Dep里的dep数组, 当dep.target存在时, 如果id不重复就往订阅器添加订阅者, dep.target赋值会在Watcher里做, 赋值后再调用一次属性触发getter, 然后把dep.target置null), 在setter里notify所有的dep, notify会调用所有的dep的update方法, 并触发Compile的回调, 更新视图.

##### mpVue原理详细阐述
典型的逻辑视图层框架, 逻辑层和视图层之间的工作方式是: 数据变更驱动视图更新, 视图交互触发事件, 事件响应函数修改数据再次触发视图更新
在mpVue中, 小程序负责视图层, 所有业务逻辑在vue.js中, vue数据变更后同步到小程序:
1. Vue实例与小程序page实例建立关联
2. mnp与Vue生命周期建立映射关系, 能在mnp生命周期中触发Vue的生命周期
3. mnp事件建立代理机制, 在事件代理函数中触发与之对应的Vue事件响应

#### 前端
##### 前端组件化 模块化 工程化的理解
组件化和模块化可以放在一起讲, 首先是颗粒度不同, 拿vue来讲, 组件化应该是包含(template+script+style)的功能完备单元. 模块化更像是js模块, 如Observer、watcher.
其次用测试的角度来看, 组件化像黑盒, 不需要知道内部逻辑, 关注io和功能性; 模块化更像白盒, 内容可见, 注重设计.
工程化可以按以下点来讲:
1 代码规范: 保证团队有统一的代码风格, 如eslint
2 分支管理: 每个迭代的分支命名或开发的模块分支命名
3 模块管理: 模块/组件命名规范 路径规范
4 自动化测试: 单元测试 集成测试 端到端测试
5 commit规范: husky校验, 包括push
6 构建: 多种构建方式, 本地构建, jenkins构建
7 部署: 多种部署方式, 本地部署, jenkins部署