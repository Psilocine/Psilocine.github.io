---
title: 2019年面试总结
date: 2019-08-27 09:59:09
tags: [前端, 随笔, 面试]
---
##### 写在前面
绝不推荐脱产寻找工作机会, 特别是非一线城市(具有时效性). 笔者始终觉得, 面试是快速提升个人实力的有效方式, 但是面试的状态真的是又累又焦虑, 也是笔者第一次经历社招, 深深觉得社招对工作年限的严格性, 有个工作3年的同事也在找工作(笔者工作1年), 但是他的面试机会比我多一倍不止, 能力虽有差距, 但是他分享的面经发现笔者能答上大部分, 着实难受. 本文记下近期面试的印象深刻的题

#### JavaScript基础
##### 设计模式: 了解单例和工厂吗 应用场景是什么
1. 单例模式(Singleton)的特点是只有一个实例对象, 且该类能自行创建这个实例的一种模式, 单例类对外提供一个访问该单例的全局访问点
```JavaScript
var createWindow = function() {
    var div;
    return function () {
        if (!div) {
            div = document.createElement('div');
            div.innerHTML = 'a toast';
            div.style.display = 'none';
            // ...
            document.body.appendChild(div);
        }
        return div;
    }
}
document.getElementById('id').onclick = function () {
    var win = createWindow();
    win.style.display = 'block';
}
// 点击创建并展示弹窗, 关闭时移除弹窗dom, 频繁dom操作影响性能, 单例只实例化一次
```
应用场景: 某类只要求生成一个对象的时候; 对象需要被共享的时候; 某类频繁实例化和频繁被销毁的时候;
<!-- more -->
2. 工厂方法模式是一类产品的生产模式, 我们把被创建的对象称为"产品", 把创建产品的对象成为"工厂", 特点是用户只需要知道具体工厂的名称就可以得到所要的产品, 无需知道产品的具体创建过程;
工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成
```html
抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。
具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
具体产品（Concrete Product）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。
```
应用场景: 只知道创建产品的工厂名, 不知道具体的产品名; 创建对象的任务由多个子工厂的某一个完成, 而抽象工厂只提供创建产品的接口; 客户不关心创建产品的细节, 只关心产品的品牌;

3. 抽象工厂模式可生产多维度的产品, 特点除了工厂方法模式的特点还有当增加一个新的产品族时不需要修改原代码, 满足开闭原则
在工厂方法模式的具体工厂实现多个产品的生成方法
应用场景: 需要创建的对象是一系列相关联或相依赖的产品族时, 如电器工厂的电视机洗衣机; 系统提供产品的类库, 且所有产品的接口相同, 客户端不依赖产品实例的创建细节和内部结构

##### es5和es6是如何继承的
```JavaScript
// es5
// 原型链实现继承: 利用原型让一个引用类型继承另一个引用类型的属性和方法
// 缺点是引用类型的值会被所以实例共享; 创造子类的实例不能向超类构造函数中传递参数
function Super() {
    this.property = true;
}
Super.prototype.getSuperValue = function () {
    return this.property;
}
function Sub() {
    this.subproperty = false;
}
Sub.prototype = new Super();
Sub.prototype.getSubValue = function () {
    return this.subproperty;
}
var sub = new Sub();
sub.getSuperValue; // true
// 借用构造函数: 在子类构造函数的内部调用超类的构造函数, 通过apply或call来修改作用域, 能够传递参数
// 缺点是方法都在构造函数中定义, 函数无法复用; 在超类定义的方法, 子类不可见
function Super () {
    this.property = true;
}
function Sub() {
    Super.call(this)
}
var sub1 = new Sub();
var sub2 = nwe Sub();
sub1.property = false;
sub1.property; // false
sub2.property; // true
// 组合继承: 讲原型链和借用构造函数组合, 原型链实现了原型属性和方法的继承, 借用构造函数实现了实例属性的继承, 函数复用, 又保证属性不会被实例共享
// 缺点是调用两次超类构造函数, 一次在创建子类原型的时候, 一次是子类构造函数的内部
function Super (name) {
    this.property = true;
    this.name = name;
}
Super.prototype.sayName = function () {
    console.log('name: ', this.name);
}
function Sub (name, age) {
    Super.call(this, name); // 参数不固定可以用apply
    this.age = age;
}

Sub.prototype = new Super();
Sub.prototype.constructor = Sub;
Sub.prototype.sayAge = function () {
    console.log('age: ', this.age);
}

var sub = new Sub('PsiloLau', 18);
sub.sayName(); // name: PsiloLau
sub.sayAge(); // age: 18
// 寄生组合式继承: 通过借用构造函数来继承属性, 是最理想的继承方式
function object(o) {
    function F() {}
    F.prototype = o;
    return new F();
}
function inheritPrototype(Sub, Super) {
    var prototype = object(Super.prototype);
    prototype.constructor = Sub;
    Sub.prototype = prototype
}
function Super (name) {
    this.name = name;
    this.colors = ['red', 'green'];
}
Super.prototype.sayName = function () {
    console.log(this.name);
}
function Sub (name, age) {
    Super.call(this, name);
    this.age = age;
}
inheritPrototype(Sub, Super);

Sub.prototype.sayAge = function () {
    console.log(this.age);
}
// es6 class与extends实现继承, 本质是es5修改原型链实现继承的语法糖
class Animal {
    constructor (props) {
        this.name = props.name || 'Animal'
    }
    eat () {
        console.log(this.name + ' can eat');
    }
    sleep () {
        console.log(this.name + ' can sleep');
    }
}

class Bird extends Animal {
    constructor (props, ownClass) {
        super(props); // 相对于获得父类的this指向
        this.type = props.type || 'Egg animal';
        this.class = ownClass
    }
    fly () {
        console.log(this.name + ' can fly');
    }
    eat () {
        console.log(this.name + ' can eat worms') // 父类方法重写
    }
}

var swollow = new Bird({
    name: '小燕子',
    type: 'Egg animal'
}, 'Bird class')
swollow.fly(); // 小燕子 can fly
swollow.sleep(); // 小燕子 can sleep
swollow.eat(); // 小燕子 can eat worms
```

##### 原生JavaScript设计组件
<!-- todo -->
##### jsonp工作原理, 为什么不是真正的ajax
原理: 利用script标签没有跨域限制的特性来达到与第三方通讯的目的, 需要通讯时创建script标签指向第三方api地址, 并提供一个回调函数来接受数据(函数名可约定, 也可通过参数传递), 客户端通过调用回调函数来进行交互.
为什么不是真正的ajax: ajax的核心的通过xmlHttpRequest获取内容, jsonp的核心是动态添加; jsonp只支持get请求; ajax不一定要用json格式来传递数据

##### requestAnimationFrame原理
<!-- todo -->

##### ['1','2','3'].map(parseInt)的输出, 为什么
```html
输出: [1, NaN, NaN]
原因: parseInt()函数可传两个参数, parseInt(string, radix)
string: 必需, 要解析的字符串.
radix: 可选, 表示要解析的数字的基数, 基于2~36之间, 不填默认为10进制, 小于2或大于36都会返回NaN. 
map()可传三个参数, map(item, index, arr)
item: 必需, 当前元素的值
index: 可选, 当前元素的索引值
arr: 可选, 当前元素属于的数组对象
['1', '2', '3'].map(parseInt) => parseInt('1', 0) (arr是第三个参数, 但是parseInt只接收两个, 所以无效) parseInt('2', 1) parseInt('3', 2) 所以是1, NaN, NaN
```

#### 浏览器
##### 预检请求options作用
<!-- todo -->

##### 对缓存的理解
<!-- todo -->

#### Vue
##### Vue原理详细阐述
<!-- todo -->

##### mpVue原理详细阐述
<!-- todo -->

#### 前端
##### 前端组件化 模块化 工程化的理解
<!-- todo -->
